"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/ideaux",{

/***/ "(pages-dir-browser)/./lib/generateAnchoringPlan.js":
/*!**************************************!*\
  !*** ./lib/generateAnchoringPlan.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// Générateur de plan d'ancrage (proposition)\n// Entrée : idéal (titre, indicateur, date_cible, fréquence/semaine, durée, intensité, jours proposés...)\n// Sortie : structure complète à valider/ajuster par l'utilisateur\n\nfunction generateAnchoringPlan(param) {\n    let { titre, indicateur, dateCible, frequence = 3, duree = 15, intensite = '7,6 km/h', joursProposes = [\n        'lundi',\n        'mercredi',\n        'samedi'\n    ], dateDebut = new Date() } = param;\n    // Calcul du nombre de semaines\n    const debut = new Date(dateDebut);\n    const fin = new Date(dateCible);\n    // Sécurisation : si dateDebut ou dateCible sont invalides, retourner un plan vide ou lever une erreur explicite\n    if (isNaN(debut.getTime()) || isNaN(fin.getTime())) {\n        throw new RangeError('Date de début ou date cible invalide');\n    }\n    const msParSemaine = 1000 * 60 * 60 * 24 * 7;\n    const nbSemaines = Math.ceil((fin - debut) / msParSemaine);\n    // Génération des objectifs intermédiaires (1 objectif global ici)\n    const objectif = {\n        titre: \"Courir \".concat(frequence, \"x/semaine pendant \").concat(duree, \" min \\xe0 \").concat(intensite),\n        frequence_par_semaine: frequence,\n        duree_unite: duree,\n        unite_duree: 'minutes',\n        intensite,\n        periode: \"\".concat(debut.toISOString().slice(0, 10), \" au \").concat(fin.toISOString().slice(0, 10)),\n        progression: 0,\n        statut: 'en cours',\n        routines: []\n    };\n    // Génération des routines (jours proposés)\n    for (let jour of joursProposes){\n        objectif.routines.push({\n            jour,\n            action_type: 'course',\n            moment: 'matin',\n            est_pilier: true\n        });\n    }\n    // Génération des actions structurées par mois > semaines > actions\n    const mois = [];\n    let currentDate = new Date(debut);\n    for(let s = 0; s < nbSemaines; s++){\n        // La semaine commence exactement à la dateDebut + s*7 jours\n        const weekStartDate = new Date(debut);\n        weekStartDate.setDate(debut.getDate() + s * 7);\n        const moisNum = weekStartDate.getMonth() + 1 + (weekStartDate.getFullYear() - debut.getFullYear()) * 12;\n        let moisObj = mois.find((m)=>m.numero === moisNum);\n        if (!moisObj) {\n            moisObj = {\n                numero: moisNum,\n                annee: weekStartDate.getFullYear(),\n                semaines: []\n            };\n            mois.push(moisObj);\n        }\n        const semaineNum = moisObj.semaines.length + 1;\n        const semaineObj = {\n            numero: semaineNum,\n            debut: weekStartDate.toISOString().slice(0, 10),\n            actions: []\n        };\n        // Générer les actions pour chaque routine/jour proposé, à partir du premier jour de la semaine\n        for(let r = 0; r < objectif.routines.length; r++){\n            const routine = objectif.routines[r];\n            const dateAction = new Date(weekStartDate);\n            dateAction.setDate(weekStartDate.getDate() + r);\n            if (dateAction > fin) continue;\n            semaineObj.actions.push({\n                date: dateAction.toISOString().slice(0, 10),\n                jour: routine.jour,\n                action_type: routine.action_type,\n                moment: routine.moment,\n                statut: 'à faire',\n                commentaire: '',\n                energie: null\n            });\n        }\n        moisObj.semaines.push(semaineObj);\n    }\n    // Structure finale à valider/ajuster par l'utilisateur\n    return {\n        ideal: {\n            titre,\n            indicateur,\n            date_cible: dateCible\n        },\n        objectif,\n        mois\n    };\n}\n// Exemple d'utilisation (à brancher sur l'UI pour validation/ajustement)\n/*\nconst plan = generateAnchoringPlan({\n  titre: \"Find back my 2023 runstatus\",\n  indicateur: \"6 km à 7,6 km/h\",\n  dateCible: \"2026-07-25\",\n  frequence: 3,\n  duree: 15,\n  intensite: \"7,6 km/h\",\n  joursProposes: [\"lundi\", \"mercredi\", \"samedi\"]\n});\nconsole.log(plan);\n*/ module.exports = {\n    generateAnchoringPlan\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2xpYi9nZW5lcmF0ZUFuY2hvcmluZ1BsYW4uanMiLCJtYXBwaW5ncyI6IkFBQUEsNkNBQTZDO0FBQzdDLHlHQUF5RztBQUN6RyxrRUFBa0U7O0FBR2xFLFNBQVNBLHNCQUFzQixLQVM5QjtRQVQ4QixFQUM3QkMsS0FBSyxFQUNMQyxVQUFVLEVBQ1ZDLFNBQVMsRUFDVEMsWUFBWSxDQUFDLEVBQ2JDLFFBQVEsRUFBRSxFQUNWQyxZQUFZLFVBQVUsRUFDdEJDLGdCQUFnQjtRQUFDO1FBQVM7UUFBWTtLQUFTLEVBQy9DQyxZQUFZLElBQUlDLE1BQU0sRUFDdkIsR0FUOEI7SUFVN0IsK0JBQStCO0lBQy9CLE1BQU1DLFFBQVEsSUFBSUQsS0FBS0Q7SUFDdkIsTUFBTUcsTUFBTSxJQUFJRixLQUFLTjtJQUNyQixnSEFBZ0g7SUFDaEgsSUFBSVMsTUFBTUYsTUFBTUcsT0FBTyxPQUFPRCxNQUFNRCxJQUFJRSxPQUFPLEtBQUs7UUFDbEQsTUFBTSxJQUFJQyxXQUFXO0lBQ3ZCO0lBQ0EsTUFBTUMsZUFBZSxPQUFPLEtBQUssS0FBSyxLQUFLO0lBQzNDLE1BQU1DLGFBQWFDLEtBQUtDLElBQUksQ0FBQyxDQUFDUCxNQUFNRCxLQUFJLElBQUtLO0lBRTdDLGtFQUFrRTtJQUNsRSxNQUFNSSxXQUFXO1FBQ2ZsQixPQUFPLFVBQXdDSSxPQUE5QkQsV0FBVSxzQkFBbUNFLE9BQWZELE9BQU0sY0FBbUIsT0FBVkM7UUFDOURjLHVCQUF1QmhCO1FBQ3ZCaUIsYUFBYWhCO1FBQ2JpQixhQUFhO1FBQ2JoQjtRQUNGaUIsU0FBUyxHQUF5Q1osT0FBdENELE1BQU1jLFdBQVcsR0FBR0MsS0FBSyxDQUFDLEdBQUUsS0FBSSxRQUFvQyxPQUE5QmQsSUFBSWEsV0FBVyxHQUFHQyxLQUFLLENBQUMsR0FBRTtRQUMxRUMsYUFBYTtRQUNiQyxRQUFRO1FBQ1JDLFVBQVUsRUFBRTtJQUNkO0lBRUEsMkNBQTJDO0lBQzNDLEtBQUssSUFBSUMsUUFBUXRCLGNBQWU7UUFDOUJZLFNBQVNTLFFBQVEsQ0FBQ0UsSUFBSSxDQUFDO1lBQ3JCRDtZQUNBRSxhQUFhO1lBQ2JDLFFBQVE7WUFDUkMsWUFBWTtRQUNkO0lBQ0Y7SUFFQSxtRUFBbUU7SUFDbkUsTUFBTUMsT0FBTyxFQUFFO0lBQ2YsSUFBSUMsY0FBYyxJQUFJMUIsS0FBS0M7SUFDM0IsSUFBSyxJQUFJMEIsSUFBSSxHQUFHQSxJQUFJcEIsWUFBWW9CLElBQUs7UUFDbkMsNERBQTREO1FBQzVELE1BQU1DLGdCQUFnQixJQUFJNUIsS0FBS0M7UUFDL0IyQixjQUFjQyxPQUFPLENBQUM1QixNQUFNNkIsT0FBTyxLQUFLSCxJQUFJO1FBQzVDLE1BQU1JLFVBQVVILGNBQWNJLFFBQVEsS0FBSyxJQUFJLENBQUNKLGNBQWNLLFdBQVcsS0FBS2hDLE1BQU1nQyxXQUFXLEVBQUMsSUFBSztRQUNyRyxJQUFJQyxVQUFVVCxLQUFLVSxJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLE1BQU0sS0FBS047UUFDMUMsSUFBSSxDQUFDRyxTQUFTO1lBQ1pBLFVBQVU7Z0JBQUVHLFFBQVFOO2dCQUFTTyxPQUFPVixjQUFjSyxXQUFXO2dCQUFJTSxVQUFVLEVBQUU7WUFBQztZQUM5RWQsS0FBS0osSUFBSSxDQUFDYTtRQUNaO1FBQ0EsTUFBTU0sYUFBYU4sUUFBUUssUUFBUSxDQUFDRSxNQUFNLEdBQUc7UUFDN0MsTUFBTUMsYUFBYTtZQUFFTCxRQUFRRztZQUFZdkMsT0FBTzJCLGNBQWNiLFdBQVcsR0FBR0MsS0FBSyxDQUFDLEdBQUU7WUFBSzJCLFNBQVMsRUFBRTtRQUFDO1FBRXJHLCtGQUErRjtRQUMvRixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSWxDLFNBQVNTLFFBQVEsQ0FBQ3NCLE1BQU0sRUFBRUcsSUFBSztZQUNqRCxNQUFNQyxVQUFVbkMsU0FBU1MsUUFBUSxDQUFDeUIsRUFBRTtZQUNwQyxNQUFNRSxhQUFhLElBQUk5QyxLQUFLNEI7WUFDNUJrQixXQUFXakIsT0FBTyxDQUFDRCxjQUFjRSxPQUFPLEtBQUtjO1lBQzdDLElBQUlFLGFBQWE1QyxLQUFLO1lBQ3RCd0MsV0FBV0MsT0FBTyxDQUFDdEIsSUFBSSxDQUFDO2dCQUN0QjBCLE1BQU1ELFdBQVcvQixXQUFXLEdBQUdDLEtBQUssQ0FBQyxHQUFFO2dCQUN2Q0ksTUFBTXlCLFFBQVF6QixJQUFJO2dCQUNsQkUsYUFBYXVCLFFBQVF2QixXQUFXO2dCQUNoQ0MsUUFBUXNCLFFBQVF0QixNQUFNO2dCQUN0QkwsUUFBUTtnQkFDUjhCLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtRQUNGO1FBQ0FmLFFBQVFLLFFBQVEsQ0FBQ2xCLElBQUksQ0FBQ3FCO0lBQ3hCO0lBRUEsdURBQXVEO0lBQ3ZELE9BQU87UUFDTFEsT0FBTztZQUNMMUQ7WUFDQUM7WUFDQTBELFlBQVl6RDtRQUNkO1FBQ0FnQjtRQUNBZTtJQUNGO0FBQ0Y7QUFFQSx5RUFBeUU7QUFDekU7Ozs7Ozs7Ozs7O0FBV0EsR0FFQTJCLE9BQU9DLE9BQU8sR0FBRztJQUFFOUQ7QUFBc0IiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL21vbi1wbGFuLXZpdGFsLXJvb3QvbGliL2dlbmVyYXRlQW5jaG9yaW5nUGxhbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBHw6luw6lyYXRldXIgZGUgcGxhbiBkJ2FuY3JhZ2UgKHByb3Bvc2l0aW9uKVxuLy8gRW50csOpZSA6IGlkw6lhbCAodGl0cmUsIGluZGljYXRldXIsIGRhdGVfY2libGUsIGZyw6lxdWVuY2Uvc2VtYWluZSwgZHVyw6llLCBpbnRlbnNpdMOpLCBqb3VycyBwcm9wb3PDqXMuLi4pXG4vLyBTb3J0aWUgOiBzdHJ1Y3R1cmUgY29tcGzDqHRlIMOgIHZhbGlkZXIvYWp1c3RlciBwYXIgbCd1dGlsaXNhdGV1clxuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlQW5jaG9yaW5nUGxhbih7XG4gIHRpdHJlLFxuICBpbmRpY2F0ZXVyLFxuICBkYXRlQ2libGUsXG4gIGZyZXF1ZW5jZSA9IDMsIC8vIHPDqWFuY2VzL3NlbWFpbmUgcGFyIGTDqWZhdXRcbiAgZHVyZWUgPSAxNSwgICAgLy8gbWludXRlc1xuICBpbnRlbnNpdGUgPSAnNyw2IGttL2gnLFxuICBqb3Vyc1Byb3Bvc2VzID0gWydsdW5kaScsICdtZXJjcmVkaScsICdzYW1lZGknXSxcbiAgZGF0ZURlYnV0ID0gbmV3IERhdGUoKVxufSkge1xuICAvLyBDYWxjdWwgZHUgbm9tYnJlIGRlIHNlbWFpbmVzXG4gIGNvbnN0IGRlYnV0ID0gbmV3IERhdGUoZGF0ZURlYnV0KTtcbiAgY29uc3QgZmluID0gbmV3IERhdGUoZGF0ZUNpYmxlKTtcbiAgLy8gU8OpY3VyaXNhdGlvbiA6IHNpIGRhdGVEZWJ1dCBvdSBkYXRlQ2libGUgc29udCBpbnZhbGlkZXMsIHJldG91cm5lciB1biBwbGFuIHZpZGUgb3UgbGV2ZXIgdW5lIGVycmV1ciBleHBsaWNpdGVcbiAgaWYgKGlzTmFOKGRlYnV0LmdldFRpbWUoKSkgfHwgaXNOYU4oZmluLmdldFRpbWUoKSkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGF0ZSBkZSBkw6lidXQgb3UgZGF0ZSBjaWJsZSBpbnZhbGlkZScpO1xuICB9XG4gIGNvbnN0IG1zUGFyU2VtYWluZSA9IDEwMDAgKiA2MCAqIDYwICogMjQgKiA3O1xuICBjb25zdCBuYlNlbWFpbmVzID0gTWF0aC5jZWlsKChmaW4gLSBkZWJ1dCkgLyBtc1BhclNlbWFpbmUpO1xuXG4gIC8vIEfDqW7DqXJhdGlvbiBkZXMgb2JqZWN0aWZzIGludGVybcOpZGlhaXJlcyAoMSBvYmplY3RpZiBnbG9iYWwgaWNpKVxuICBjb25zdCBvYmplY3RpZiA9IHtcbiAgICB0aXRyZTogYENvdXJpciAke2ZyZXF1ZW5jZX14L3NlbWFpbmUgcGVuZGFudCAke2R1cmVlfSBtaW4gw6AgJHtpbnRlbnNpdGV9YCxcbiAgICBmcmVxdWVuY2VfcGFyX3NlbWFpbmU6IGZyZXF1ZW5jZSxcbiAgICBkdXJlZV91bml0ZTogZHVyZWUsXG4gICAgdW5pdGVfZHVyZWU6ICdtaW51dGVzJyxcbiAgICBpbnRlbnNpdGUsXG4gIHBlcmlvZGU6IGAke2RlYnV0LnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwxMCl9IGF1ICR7ZmluLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwxMCl9YCxcbiAgICBwcm9ncmVzc2lvbjogMCxcbiAgICBzdGF0dXQ6ICdlbiBjb3VycycsXG4gICAgcm91dGluZXM6IFtdXG4gIH07XG5cbiAgLy8gR8OpbsOpcmF0aW9uIGRlcyByb3V0aW5lcyAoam91cnMgcHJvcG9zw6lzKVxuICBmb3IgKGxldCBqb3VyIG9mIGpvdXJzUHJvcG9zZXMpIHtcbiAgICBvYmplY3RpZi5yb3V0aW5lcy5wdXNoKHtcbiAgICAgIGpvdXIsXG4gICAgICBhY3Rpb25fdHlwZTogJ2NvdXJzZScsXG4gICAgICBtb21lbnQ6ICdtYXRpbicsXG4gICAgICBlc3RfcGlsaWVyOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICAvLyBHw6luw6lyYXRpb24gZGVzIGFjdGlvbnMgc3RydWN0dXLDqWVzIHBhciBtb2lzID4gc2VtYWluZXMgPiBhY3Rpb25zXG4gIGNvbnN0IG1vaXMgPSBbXTtcbiAgbGV0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoZGVidXQpO1xuICBmb3IgKGxldCBzID0gMDsgcyA8IG5iU2VtYWluZXM7IHMrKykge1xuICAgIC8vIExhIHNlbWFpbmUgY29tbWVuY2UgZXhhY3RlbWVudCDDoCBsYSBkYXRlRGVidXQgKyBzKjcgam91cnNcbiAgICBjb25zdCB3ZWVrU3RhcnREYXRlID0gbmV3IERhdGUoZGVidXQpO1xuICAgIHdlZWtTdGFydERhdGUuc2V0RGF0ZShkZWJ1dC5nZXREYXRlKCkgKyBzICogNyk7XG4gICAgY29uc3QgbW9pc051bSA9IHdlZWtTdGFydERhdGUuZ2V0TW9udGgoKSArIDEgKyAod2Vla1N0YXJ0RGF0ZS5nZXRGdWxsWWVhcigpIC0gZGVidXQuZ2V0RnVsbFllYXIoKSkgKiAxMjtcbiAgICBsZXQgbW9pc09iaiA9IG1vaXMuZmluZChtID0+IG0ubnVtZXJvID09PSBtb2lzTnVtKTtcbiAgICBpZiAoIW1vaXNPYmopIHtcbiAgICAgIG1vaXNPYmogPSB7IG51bWVybzogbW9pc051bSwgYW5uZWU6IHdlZWtTdGFydERhdGUuZ2V0RnVsbFllYXIoKSwgc2VtYWluZXM6IFtdIH07XG4gICAgICBtb2lzLnB1c2gobW9pc09iaik7XG4gICAgfVxuICAgIGNvbnN0IHNlbWFpbmVOdW0gPSBtb2lzT2JqLnNlbWFpbmVzLmxlbmd0aCArIDE7XG4gICAgY29uc3Qgc2VtYWluZU9iaiA9IHsgbnVtZXJvOiBzZW1haW5lTnVtLCBkZWJ1dDogd2Vla1N0YXJ0RGF0ZS50b0lTT1N0cmluZygpLnNsaWNlKDAsMTApLCBhY3Rpb25zOiBbXSB9O1xuXG4gICAgLy8gR8OpbsOpcmVyIGxlcyBhY3Rpb25zIHBvdXIgY2hhcXVlIHJvdXRpbmUvam91ciBwcm9wb3PDqSwgw6AgcGFydGlyIGR1IHByZW1pZXIgam91ciBkZSBsYSBzZW1haW5lXG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCBvYmplY3RpZi5yb3V0aW5lcy5sZW5ndGg7IHIrKykge1xuICAgICAgY29uc3Qgcm91dGluZSA9IG9iamVjdGlmLnJvdXRpbmVzW3JdO1xuICAgICAgY29uc3QgZGF0ZUFjdGlvbiA9IG5ldyBEYXRlKHdlZWtTdGFydERhdGUpO1xuICAgICAgZGF0ZUFjdGlvbi5zZXREYXRlKHdlZWtTdGFydERhdGUuZ2V0RGF0ZSgpICsgcik7XG4gICAgICBpZiAoZGF0ZUFjdGlvbiA+IGZpbikgY29udGludWU7XG4gICAgICBzZW1haW5lT2JqLmFjdGlvbnMucHVzaCh7XG4gICAgICAgIGRhdGU6IGRhdGVBY3Rpb24udG9JU09TdHJpbmcoKS5zbGljZSgwLDEwKSxcbiAgICAgICAgam91cjogcm91dGluZS5qb3VyLFxuICAgICAgICBhY3Rpb25fdHlwZTogcm91dGluZS5hY3Rpb25fdHlwZSxcbiAgICAgICAgbW9tZW50OiByb3V0aW5lLm1vbWVudCxcbiAgICAgICAgc3RhdHV0OiAnw6AgZmFpcmUnLFxuICAgICAgICBjb21tZW50YWlyZTogJycsXG4gICAgICAgIGVuZXJnaWU6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBtb2lzT2JqLnNlbWFpbmVzLnB1c2goc2VtYWluZU9iaik7XG4gIH1cblxuICAvLyBTdHJ1Y3R1cmUgZmluYWxlIMOgIHZhbGlkZXIvYWp1c3RlciBwYXIgbCd1dGlsaXNhdGV1clxuICByZXR1cm4ge1xuICAgIGlkZWFsOiB7XG4gICAgICB0aXRyZSxcbiAgICAgIGluZGljYXRldXIsXG4gICAgICBkYXRlX2NpYmxlOiBkYXRlQ2libGVcbiAgICB9LFxuICAgIG9iamVjdGlmLFxuICAgIG1vaXNcbiAgfTtcbn1cblxuLy8gRXhlbXBsZSBkJ3V0aWxpc2F0aW9uICjDoCBicmFuY2hlciBzdXIgbCdVSSBwb3VyIHZhbGlkYXRpb24vYWp1c3RlbWVudClcbi8qXG5jb25zdCBwbGFuID0gZ2VuZXJhdGVBbmNob3JpbmdQbGFuKHtcbiAgdGl0cmU6IFwiRmluZCBiYWNrIG15IDIwMjMgcnVuc3RhdHVzXCIsXG4gIGluZGljYXRldXI6IFwiNiBrbSDDoCA3LDYga20vaFwiLFxuICBkYXRlQ2libGU6IFwiMjAyNi0wNy0yNVwiLFxuICBmcmVxdWVuY2U6IDMsXG4gIGR1cmVlOiAxNSxcbiAgaW50ZW5zaXRlOiBcIjcsNiBrbS9oXCIsXG4gIGpvdXJzUHJvcG9zZXM6IFtcImx1bmRpXCIsIFwibWVyY3JlZGlcIiwgXCJzYW1lZGlcIl1cbn0pO1xuY29uc29sZS5sb2cocGxhbik7XG4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZ2VuZXJhdGVBbmNob3JpbmdQbGFuIH07Il0sIm5hbWVzIjpbImdlbmVyYXRlQW5jaG9yaW5nUGxhbiIsInRpdHJlIiwiaW5kaWNhdGV1ciIsImRhdGVDaWJsZSIsImZyZXF1ZW5jZSIsImR1cmVlIiwiaW50ZW5zaXRlIiwiam91cnNQcm9wb3NlcyIsImRhdGVEZWJ1dCIsIkRhdGUiLCJkZWJ1dCIsImZpbiIsImlzTmFOIiwiZ2V0VGltZSIsIlJhbmdlRXJyb3IiLCJtc1BhclNlbWFpbmUiLCJuYlNlbWFpbmVzIiwiTWF0aCIsImNlaWwiLCJvYmplY3RpZiIsImZyZXF1ZW5jZV9wYXJfc2VtYWluZSIsImR1cmVlX3VuaXRlIiwidW5pdGVfZHVyZWUiLCJwZXJpb2RlIiwidG9JU09TdHJpbmciLCJzbGljZSIsInByb2dyZXNzaW9uIiwic3RhdHV0Iiwicm91dGluZXMiLCJqb3VyIiwicHVzaCIsImFjdGlvbl90eXBlIiwibW9tZW50IiwiZXN0X3BpbGllciIsIm1vaXMiLCJjdXJyZW50RGF0ZSIsInMiLCJ3ZWVrU3RhcnREYXRlIiwic2V0RGF0ZSIsImdldERhdGUiLCJtb2lzTnVtIiwiZ2V0TW9udGgiLCJnZXRGdWxsWWVhciIsIm1vaXNPYmoiLCJmaW5kIiwibSIsIm51bWVybyIsImFubmVlIiwic2VtYWluZXMiLCJzZW1haW5lTnVtIiwibGVuZ3RoIiwic2VtYWluZU9iaiIsImFjdGlvbnMiLCJyIiwicm91dGluZSIsImRhdGVBY3Rpb24iLCJkYXRlIiwiY29tbWVudGFpcmUiLCJlbmVyZ2llIiwiaWRlYWwiLCJkYXRlX2NpYmxlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./lib/generateAnchoringPlan.js\n"));

/***/ })

});