"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/ideaux",{

/***/ "(pages-dir-browser)/./lib/generateAnchoringPlan.js":
/*!**************************************!*\
  !*** ./lib/generateAnchoringPlan.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// Générateur de plan d'ancrage (proposition)\n// Entrée : idéal (titre, indicateur, date_cible, fréquence/semaine, durée, intensité, jours proposés...)\n// Sortie : structure complète à valider/ajuster par l'utilisateur\n\nfunction generateAnchoringPlan(param) {\n    let { titre, indicateur, dateCible, frequence = 3, duree = 15, intensite = '7,6 km/h', joursProposes = [\n        'lundi',\n        'mercredi',\n        'samedi'\n    ], dateDebut = new Date() } = param;\n    // Calcul du nombre de semaines\n    const debut = new Date(dateDebut);\n    const fin = new Date(dateCible);\n    // Sécurisation : si dateDebut ou dateCible sont invalides, retourner un plan vide ou lever une erreur explicite\n    if (isNaN(debut.getTime()) || isNaN(fin.getTime())) {\n        throw new RangeError('Date de début ou date cible invalide');\n    }\n    const msParSemaine = 1000 * 60 * 60 * 24 * 7;\n    const nbSemaines = Math.ceil((fin - debut) / msParSemaine);\n    // Génération des objectifs intermédiaires (1 objectif global ici)\n    const objectif = {\n        titre: \"Courir \".concat(frequence, \"x/semaine pendant \").concat(duree, \" min \\xe0 \").concat(intensite),\n        frequence_par_semaine: frequence,\n        duree_unite: duree,\n        unite_duree: 'minutes',\n        intensite,\n        periode: \"\".concat(debut.toISOString().slice(0, 10), \" au \").concat(fin.toISOString().slice(0, 10)),\n        progression: 0,\n        statut: 'en cours',\n        routines: []\n    };\n    // Génération des routines (jours proposés)\n    for (let jour of joursProposes){\n        objectif.routines.push({\n            jour,\n            action_type: 'course',\n            moment: 'matin',\n            est_pilier: true\n        });\n    }\n    // Génération des actions structurées par mois > semaines > actions\n    const mois = [];\n    let currentDate = new Date(debut);\n    for(let s = 0; s < nbSemaines; s++){\n        // Calcul du mois et de la semaine dans le mois\n        const weekStartDate = new Date(debut);\n        weekStartDate.setDate(debut.getDate() + s * 7);\n        const moisNum = weekStartDate.getMonth() + 1 + (weekStartDate.getFullYear() - debut.getFullYear()) * 12;\n        let moisObj = mois.find((m)=>m.numero === moisNum);\n        if (!moisObj) {\n            moisObj = {\n                numero: moisNum,\n                annee: weekStartDate.getFullYear(),\n                semaines: []\n            };\n            mois.push(moisObj);\n        }\n        const semaineNum = moisObj.semaines.length + 1;\n        const semaineObj = {\n            numero: semaineNum,\n            debut: weekStartDate.toISOString().slice(0, 10),\n            actions: []\n        };\n        // Générer les actions pour chaque routine/jour proposé\n        for(let r = 0; r < objectif.routines.length; r++){\n            const routine = objectif.routines[r];\n            const dateAction = new Date(weekStartDate);\n            dateAction.setDate(weekStartDate.getDate() + r);\n            if (dateAction > fin) continue;\n            semaineObj.actions.push({\n                date: dateAction.toISOString().slice(0, 10),\n                jour: routine.jour,\n                action_type: routine.action_type,\n                moment: routine.moment,\n                statut: 'à faire',\n                commentaire: '',\n                energie: null\n            });\n        }\n        moisObj.semaines.push(semaineObj);\n    }\n    // Structure finale à valider/ajuster par l'utilisateur\n    return {\n        ideal: {\n            titre,\n            indicateur,\n            date_cible: dateCible\n        },\n        objectif,\n        mois\n    };\n}\n// Exemple d'utilisation (à brancher sur l'UI pour validation/ajustement)\n/*\nconst plan = generateAnchoringPlan({\n  titre: \"Find back my 2023 runstatus\",\n  indicateur: \"6 km à 7,6 km/h\",\n  dateCible: \"2026-07-25\",\n  frequence: 3,\n  duree: 15,\n  intensite: \"7,6 km/h\",\n  joursProposes: [\"lundi\", \"mercredi\", \"samedi\"]\n});\nconsole.log(plan);\n*/ module.exports = {\n    generateAnchoringPlan\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2xpYi9nZW5lcmF0ZUFuY2hvcmluZ1BsYW4uanMiLCJtYXBwaW5ncyI6IkFBQUEsNkNBQTZDO0FBQzdDLHlHQUF5RztBQUN6RyxrRUFBa0U7O0FBR2xFLFNBQVNBLHNCQUFzQixLQVM5QjtRQVQ4QixFQUM3QkMsS0FBSyxFQUNMQyxVQUFVLEVBQ1ZDLFNBQVMsRUFDVEMsWUFBWSxDQUFDLEVBQ2JDLFFBQVEsRUFBRSxFQUNWQyxZQUFZLFVBQVUsRUFDdEJDLGdCQUFnQjtRQUFDO1FBQVM7UUFBWTtLQUFTLEVBQy9DQyxZQUFZLElBQUlDLE1BQU0sRUFDdkIsR0FUOEI7SUFVN0IsK0JBQStCO0lBQy9CLE1BQU1DLFFBQVEsSUFBSUQsS0FBS0Q7SUFDdkIsTUFBTUcsTUFBTSxJQUFJRixLQUFLTjtJQUNyQixnSEFBZ0g7SUFDaEgsSUFBSVMsTUFBTUYsTUFBTUcsT0FBTyxPQUFPRCxNQUFNRCxJQUFJRSxPQUFPLEtBQUs7UUFDbEQsTUFBTSxJQUFJQyxXQUFXO0lBQ3ZCO0lBQ0EsTUFBTUMsZUFBZSxPQUFPLEtBQUssS0FBSyxLQUFLO0lBQzNDLE1BQU1DLGFBQWFDLEtBQUtDLElBQUksQ0FBQyxDQUFDUCxNQUFNRCxLQUFJLElBQUtLO0lBRTdDLGtFQUFrRTtJQUNsRSxNQUFNSSxXQUFXO1FBQ2ZsQixPQUFPLFVBQXdDSSxPQUE5QkQsV0FBVSxzQkFBbUNFLE9BQWZELE9BQU0sY0FBbUIsT0FBVkM7UUFDOURjLHVCQUF1QmhCO1FBQ3ZCaUIsYUFBYWhCO1FBQ2JpQixhQUFhO1FBQ2JoQjtRQUNGaUIsU0FBUyxHQUF5Q1osT0FBdENELE1BQU1jLFdBQVcsR0FBR0MsS0FBSyxDQUFDLEdBQUUsS0FBSSxRQUFvQyxPQUE5QmQsSUFBSWEsV0FBVyxHQUFHQyxLQUFLLENBQUMsR0FBRTtRQUMxRUMsYUFBYTtRQUNiQyxRQUFRO1FBQ1JDLFVBQVUsRUFBRTtJQUNkO0lBRUEsMkNBQTJDO0lBQzNDLEtBQUssSUFBSUMsUUFBUXRCLGNBQWU7UUFDOUJZLFNBQVNTLFFBQVEsQ0FBQ0UsSUFBSSxDQUFDO1lBQ3JCRDtZQUNBRSxhQUFhO1lBQ2JDLFFBQVE7WUFDUkMsWUFBWTtRQUNkO0lBQ0Y7SUFFQSxtRUFBbUU7SUFDbkUsTUFBTUMsT0FBTyxFQUFFO0lBQ2YsSUFBSUMsY0FBYyxJQUFJMUIsS0FBS0M7SUFDM0IsSUFBSyxJQUFJMEIsSUFBSSxHQUFHQSxJQUFJcEIsWUFBWW9CLElBQUs7UUFDbkMsK0NBQStDO1FBQy9DLE1BQU1DLGdCQUFnQixJQUFJNUIsS0FBS0M7UUFDL0IyQixjQUFjQyxPQUFPLENBQUM1QixNQUFNNkIsT0FBTyxLQUFLSCxJQUFJO1FBQzVDLE1BQU1JLFVBQVVILGNBQWNJLFFBQVEsS0FBSyxJQUFJLENBQUNKLGNBQWNLLFdBQVcsS0FBS2hDLE1BQU1nQyxXQUFXLEVBQUMsSUFBSztRQUNyRyxJQUFJQyxVQUFVVCxLQUFLVSxJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLE1BQU0sS0FBS047UUFDMUMsSUFBSSxDQUFDRyxTQUFTO1lBQ1pBLFVBQVU7Z0JBQUVHLFFBQVFOO2dCQUFTTyxPQUFPVixjQUFjSyxXQUFXO2dCQUFJTSxVQUFVLEVBQUU7WUFBQztZQUM5RWQsS0FBS0osSUFBSSxDQUFDYTtRQUNaO1FBQ0EsTUFBTU0sYUFBYU4sUUFBUUssUUFBUSxDQUFDRSxNQUFNLEdBQUc7UUFDN0MsTUFBTUMsYUFBYTtZQUFFTCxRQUFRRztZQUFZdkMsT0FBTzJCLGNBQWNiLFdBQVcsR0FBR0MsS0FBSyxDQUFDLEdBQUU7WUFBSzJCLFNBQVMsRUFBRTtRQUFDO1FBRXJHLHVEQUF1RDtRQUN2RCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSWxDLFNBQVNTLFFBQVEsQ0FBQ3NCLE1BQU0sRUFBRUcsSUFBSztZQUNqRCxNQUFNQyxVQUFVbkMsU0FBU1MsUUFBUSxDQUFDeUIsRUFBRTtZQUNwQyxNQUFNRSxhQUFhLElBQUk5QyxLQUFLNEI7WUFDNUJrQixXQUFXakIsT0FBTyxDQUFDRCxjQUFjRSxPQUFPLEtBQUtjO1lBQzdDLElBQUlFLGFBQWE1QyxLQUFLO1lBQ3RCd0MsV0FBV0MsT0FBTyxDQUFDdEIsSUFBSSxDQUFDO2dCQUN0QjBCLE1BQU1ELFdBQVcvQixXQUFXLEdBQUdDLEtBQUssQ0FBQyxHQUFFO2dCQUN2Q0ksTUFBTXlCLFFBQVF6QixJQUFJO2dCQUNsQkUsYUFBYXVCLFFBQVF2QixXQUFXO2dCQUNoQ0MsUUFBUXNCLFFBQVF0QixNQUFNO2dCQUN0QkwsUUFBUTtnQkFDUjhCLGFBQWE7Z0JBQ2JDLFNBQVM7WUFDWDtRQUNGO1FBQ0FmLFFBQVFLLFFBQVEsQ0FBQ2xCLElBQUksQ0FBQ3FCO0lBQ3hCO0lBRUEsdURBQXVEO0lBQ3ZELE9BQU87UUFDTFEsT0FBTztZQUNMMUQ7WUFDQUM7WUFDQTBELFlBQVl6RDtRQUNkO1FBQ0FnQjtRQUNBZTtJQUNGO0FBQ0Y7QUFFQSx5RUFBeUU7QUFDekU7Ozs7Ozs7Ozs7O0FBV0EsR0FFQTJCLE9BQU9DLE9BQU8sR0FBRztJQUFFOUQ7QUFBc0IiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL21vbi1wbGFuLXZpdGFsLXJvb3QvbGliL2dlbmVyYXRlQW5jaG9yaW5nUGxhbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBHw6luw6lyYXRldXIgZGUgcGxhbiBkJ2FuY3JhZ2UgKHByb3Bvc2l0aW9uKVxuLy8gRW50csOpZSA6IGlkw6lhbCAodGl0cmUsIGluZGljYXRldXIsIGRhdGVfY2libGUsIGZyw6lxdWVuY2Uvc2VtYWluZSwgZHVyw6llLCBpbnRlbnNpdMOpLCBqb3VycyBwcm9wb3PDqXMuLi4pXG4vLyBTb3J0aWUgOiBzdHJ1Y3R1cmUgY29tcGzDqHRlIMOgIHZhbGlkZXIvYWp1c3RlciBwYXIgbCd1dGlsaXNhdGV1clxuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlQW5jaG9yaW5nUGxhbih7XG4gIHRpdHJlLFxuICBpbmRpY2F0ZXVyLFxuICBkYXRlQ2libGUsXG4gIGZyZXF1ZW5jZSA9IDMsIC8vIHPDqWFuY2VzL3NlbWFpbmUgcGFyIGTDqWZhdXRcbiAgZHVyZWUgPSAxNSwgICAgLy8gbWludXRlc1xuICBpbnRlbnNpdGUgPSAnNyw2IGttL2gnLFxuICBqb3Vyc1Byb3Bvc2VzID0gWydsdW5kaScsICdtZXJjcmVkaScsICdzYW1lZGknXSxcbiAgZGF0ZURlYnV0ID0gbmV3IERhdGUoKVxufSkge1xuICAvLyBDYWxjdWwgZHUgbm9tYnJlIGRlIHNlbWFpbmVzXG4gIGNvbnN0IGRlYnV0ID0gbmV3IERhdGUoZGF0ZURlYnV0KTtcbiAgY29uc3QgZmluID0gbmV3IERhdGUoZGF0ZUNpYmxlKTtcbiAgLy8gU8OpY3VyaXNhdGlvbiA6IHNpIGRhdGVEZWJ1dCBvdSBkYXRlQ2libGUgc29udCBpbnZhbGlkZXMsIHJldG91cm5lciB1biBwbGFuIHZpZGUgb3UgbGV2ZXIgdW5lIGVycmV1ciBleHBsaWNpdGVcbiAgaWYgKGlzTmFOKGRlYnV0LmdldFRpbWUoKSkgfHwgaXNOYU4oZmluLmdldFRpbWUoKSkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGF0ZSBkZSBkw6lidXQgb3UgZGF0ZSBjaWJsZSBpbnZhbGlkZScpO1xuICB9XG4gIGNvbnN0IG1zUGFyU2VtYWluZSA9IDEwMDAgKiA2MCAqIDYwICogMjQgKiA3O1xuICBjb25zdCBuYlNlbWFpbmVzID0gTWF0aC5jZWlsKChmaW4gLSBkZWJ1dCkgLyBtc1BhclNlbWFpbmUpO1xuXG4gIC8vIEfDqW7DqXJhdGlvbiBkZXMgb2JqZWN0aWZzIGludGVybcOpZGlhaXJlcyAoMSBvYmplY3RpZiBnbG9iYWwgaWNpKVxuICBjb25zdCBvYmplY3RpZiA9IHtcbiAgICB0aXRyZTogYENvdXJpciAke2ZyZXF1ZW5jZX14L3NlbWFpbmUgcGVuZGFudCAke2R1cmVlfSBtaW4gw6AgJHtpbnRlbnNpdGV9YCxcbiAgICBmcmVxdWVuY2VfcGFyX3NlbWFpbmU6IGZyZXF1ZW5jZSxcbiAgICBkdXJlZV91bml0ZTogZHVyZWUsXG4gICAgdW5pdGVfZHVyZWU6ICdtaW51dGVzJyxcbiAgICBpbnRlbnNpdGUsXG4gIHBlcmlvZGU6IGAke2RlYnV0LnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwxMCl9IGF1ICR7ZmluLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwxMCl9YCxcbiAgICBwcm9ncmVzc2lvbjogMCxcbiAgICBzdGF0dXQ6ICdlbiBjb3VycycsXG4gICAgcm91dGluZXM6IFtdXG4gIH07XG5cbiAgLy8gR8OpbsOpcmF0aW9uIGRlcyByb3V0aW5lcyAoam91cnMgcHJvcG9zw6lzKVxuICBmb3IgKGxldCBqb3VyIG9mIGpvdXJzUHJvcG9zZXMpIHtcbiAgICBvYmplY3RpZi5yb3V0aW5lcy5wdXNoKHtcbiAgICAgIGpvdXIsXG4gICAgICBhY3Rpb25fdHlwZTogJ2NvdXJzZScsXG4gICAgICBtb21lbnQ6ICdtYXRpbicsXG4gICAgICBlc3RfcGlsaWVyOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICAvLyBHw6luw6lyYXRpb24gZGVzIGFjdGlvbnMgc3RydWN0dXLDqWVzIHBhciBtb2lzID4gc2VtYWluZXMgPiBhY3Rpb25zXG4gIGNvbnN0IG1vaXMgPSBbXTtcbiAgbGV0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoZGVidXQpO1xuICBmb3IgKGxldCBzID0gMDsgcyA8IG5iU2VtYWluZXM7IHMrKykge1xuICAgIC8vIENhbGN1bCBkdSBtb2lzIGV0IGRlIGxhIHNlbWFpbmUgZGFucyBsZSBtb2lzXG4gICAgY29uc3Qgd2Vla1N0YXJ0RGF0ZSA9IG5ldyBEYXRlKGRlYnV0KTtcbiAgICB3ZWVrU3RhcnREYXRlLnNldERhdGUoZGVidXQuZ2V0RGF0ZSgpICsgcyAqIDcpO1xuICAgIGNvbnN0IG1vaXNOdW0gPSB3ZWVrU3RhcnREYXRlLmdldE1vbnRoKCkgKyAxICsgKHdlZWtTdGFydERhdGUuZ2V0RnVsbFllYXIoKSAtIGRlYnV0LmdldEZ1bGxZZWFyKCkpICogMTI7XG4gICAgbGV0IG1vaXNPYmogPSBtb2lzLmZpbmQobSA9PiBtLm51bWVybyA9PT0gbW9pc051bSk7XG4gICAgaWYgKCFtb2lzT2JqKSB7XG4gICAgICBtb2lzT2JqID0geyBudW1lcm86IG1vaXNOdW0sIGFubmVlOiB3ZWVrU3RhcnREYXRlLmdldEZ1bGxZZWFyKCksIHNlbWFpbmVzOiBbXSB9O1xuICAgICAgbW9pcy5wdXNoKG1vaXNPYmopO1xuICAgIH1cbiAgICBjb25zdCBzZW1haW5lTnVtID0gbW9pc09iai5zZW1haW5lcy5sZW5ndGggKyAxO1xuICAgIGNvbnN0IHNlbWFpbmVPYmogPSB7IG51bWVybzogc2VtYWluZU51bSwgZGVidXQ6IHdlZWtTdGFydERhdGUudG9JU09TdHJpbmcoKS5zbGljZSgwLDEwKSwgYWN0aW9uczogW10gfTtcblxuICAgIC8vIEfDqW7DqXJlciBsZXMgYWN0aW9ucyBwb3VyIGNoYXF1ZSByb3V0aW5lL2pvdXIgcHJvcG9zw6lcbiAgICBmb3IgKGxldCByID0gMDsgciA8IG9iamVjdGlmLnJvdXRpbmVzLmxlbmd0aDsgcisrKSB7XG4gICAgICBjb25zdCByb3V0aW5lID0gb2JqZWN0aWYucm91dGluZXNbcl07XG4gICAgICBjb25zdCBkYXRlQWN0aW9uID0gbmV3IERhdGUod2Vla1N0YXJ0RGF0ZSk7XG4gICAgICBkYXRlQWN0aW9uLnNldERhdGUod2Vla1N0YXJ0RGF0ZS5nZXREYXRlKCkgKyByKTtcbiAgICAgIGlmIChkYXRlQWN0aW9uID4gZmluKSBjb250aW51ZTtcbiAgICAgIHNlbWFpbmVPYmouYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgZGF0ZTogZGF0ZUFjdGlvbi50b0lTT1N0cmluZygpLnNsaWNlKDAsMTApLFxuICAgICAgICBqb3VyOiByb3V0aW5lLmpvdXIsXG4gICAgICAgIGFjdGlvbl90eXBlOiByb3V0aW5lLmFjdGlvbl90eXBlLFxuICAgICAgICBtb21lbnQ6IHJvdXRpbmUubW9tZW50LFxuICAgICAgICBzdGF0dXQ6ICfDoCBmYWlyZScsXG4gICAgICAgIGNvbW1lbnRhaXJlOiAnJyxcbiAgICAgICAgZW5lcmdpZTogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICAgIG1vaXNPYmouc2VtYWluZXMucHVzaChzZW1haW5lT2JqKTtcbiAgfVxuXG4gIC8vIFN0cnVjdHVyZSBmaW5hbGUgw6AgdmFsaWRlci9hanVzdGVyIHBhciBsJ3V0aWxpc2F0ZXVyXG4gIHJldHVybiB7XG4gICAgaWRlYWw6IHtcbiAgICAgIHRpdHJlLFxuICAgICAgaW5kaWNhdGV1cixcbiAgICAgIGRhdGVfY2libGU6IGRhdGVDaWJsZVxuICAgIH0sXG4gICAgb2JqZWN0aWYsXG4gICAgbW9pc1xuICB9O1xufVxuXG4vLyBFeGVtcGxlIGQndXRpbGlzYXRpb24gKMOgIGJyYW5jaGVyIHN1ciBsJ1VJIHBvdXIgdmFsaWRhdGlvbi9hanVzdGVtZW50KVxuLypcbmNvbnN0IHBsYW4gPSBnZW5lcmF0ZUFuY2hvcmluZ1BsYW4oe1xuICB0aXRyZTogXCJGaW5kIGJhY2sgbXkgMjAyMyBydW5zdGF0dXNcIixcbiAgaW5kaWNhdGV1cjogXCI2IGttIMOgIDcsNiBrbS9oXCIsXG4gIGRhdGVDaWJsZTogXCIyMDI2LTA3LTI1XCIsXG4gIGZyZXF1ZW5jZTogMyxcbiAgZHVyZWU6IDE1LFxuICBpbnRlbnNpdGU6IFwiNyw2IGttL2hcIixcbiAgam91cnNQcm9wb3NlczogW1wibHVuZGlcIiwgXCJtZXJjcmVkaVwiLCBcInNhbWVkaVwiXVxufSk7XG5jb25zb2xlLmxvZyhwbGFuKTtcbiovXG5cbm1vZHVsZS5leHBvcnRzID0geyBnZW5lcmF0ZUFuY2hvcmluZ1BsYW4gfTsiXSwibmFtZXMiOlsiZ2VuZXJhdGVBbmNob3JpbmdQbGFuIiwidGl0cmUiLCJpbmRpY2F0ZXVyIiwiZGF0ZUNpYmxlIiwiZnJlcXVlbmNlIiwiZHVyZWUiLCJpbnRlbnNpdGUiLCJqb3Vyc1Byb3Bvc2VzIiwiZGF0ZURlYnV0IiwiRGF0ZSIsImRlYnV0IiwiZmluIiwiaXNOYU4iLCJnZXRUaW1lIiwiUmFuZ2VFcnJvciIsIm1zUGFyU2VtYWluZSIsIm5iU2VtYWluZXMiLCJNYXRoIiwiY2VpbCIsIm9iamVjdGlmIiwiZnJlcXVlbmNlX3Bhcl9zZW1haW5lIiwiZHVyZWVfdW5pdGUiLCJ1bml0ZV9kdXJlZSIsInBlcmlvZGUiLCJ0b0lTT1N0cmluZyIsInNsaWNlIiwicHJvZ3Jlc3Npb24iLCJzdGF0dXQiLCJyb3V0aW5lcyIsImpvdXIiLCJwdXNoIiwiYWN0aW9uX3R5cGUiLCJtb21lbnQiLCJlc3RfcGlsaWVyIiwibW9pcyIsImN1cnJlbnREYXRlIiwicyIsIndlZWtTdGFydERhdGUiLCJzZXREYXRlIiwiZ2V0RGF0ZSIsIm1vaXNOdW0iLCJnZXRNb250aCIsImdldEZ1bGxZZWFyIiwibW9pc09iaiIsImZpbmQiLCJtIiwibnVtZXJvIiwiYW5uZWUiLCJzZW1haW5lcyIsInNlbWFpbmVOdW0iLCJsZW5ndGgiLCJzZW1haW5lT2JqIiwiYWN0aW9ucyIsInIiLCJyb3V0aW5lIiwiZGF0ZUFjdGlvbiIsImRhdGUiLCJjb21tZW50YWlyZSIsImVuZXJnaWUiLCJpZGVhbCIsImRhdGVfY2libGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./lib/generateAnchoringPlan.js\n"));

/***/ })

});